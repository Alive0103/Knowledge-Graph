# 日志管理系统说明

## 概述

日志管理系统确保**所有print输出都会被记录到文件**，打印一次就写入一次，不会丢失任何控制台输出。

## 核心设计原理

### 1. **Tee机制：同时写入文件和控制台**

系统使用`Tee`类重定向`sys.stdout`和`sys.stderr`，实现：
- **每次print/写入时立即刷新**：调用`file.flush()`确保数据立即写入磁盘
- **同时输出到控制台和文件**：用户可以看到实时输出，同时所有内容都被记录
- **文件以追加模式打开**：多个步骤可以写入同一个文件

```python
class Tee:
    def write(self, text):
        # 过滤进度条后写入文件
        self.file.write(filtered_text)
        self.file.flush()  # ⚠️ 关键：立即刷新，确保不丢失
        
        # 同时输出到控制台
        self.original_stream.write(text)
        self.original_stream.flush()
```

### 2. **Tee对象复用机制**

当多个步骤使用同一个日志文件时（如数据集对比模式），系统会：
- **复用Tee对象**：避免重复创建和关闭文件
- **引用计数管理**：只有当所有使用该文件的步骤都结束时，才关闭文件
- **确保文件持续打开**：子进程的输出也能被正确捕获

```python
# 第一次使用config_log_file时，创建Tee对象
with step_logger.step("步骤1", log_file=config_log_file):
    print("步骤1的输出")  # 写入config_log_file

# 第二次使用同一个文件时，复用Tee对象
with step_logger.step("步骤2", log_file=config_log_file):
    print("步骤2的输出")  # 追加到config_log_file
```

### 3. **日志文件结构简化**

**所有日志文件直接保存在`trainlog`目录下，不创建子目录**：

```
trainlog/
├── dataset_comparison_summary_20251210_120000.log    # 会话摘要
├── config_1_traindata_only_20251210_120000.log       # 配置1的所有步骤日志
├── config_2_ccks_only_20251210_120000.log            # 配置2的所有步骤日志
└── config_3_train_txt_only_20251210_120000.log       # 配置3的所有步骤日志
```

## 使用方法

### 数据集对比模式（推荐）

```python
from step_logger import StepLogger

# 创建日志管理器（所有日志文件直接保存在trainlog目录下）
step_logger = StepLogger(
    base_dir="trainlog",
    session_name="dataset_comparison",
    filter_tqdm=True
)

# 为每个配置创建一个统一的日志文件
config_log_file = "trainlog/config_1_traindata_only_20251210_120000.log"

# 所有步骤的输出都写入同一个文件
with step_logger.step("步骤1: 更新数据源配置", log_file=config_log_file):
    print("更新配置中...")  # ✅ 会被记录到config_log_file
    update_config()

with step_logger.step("步骤2: 训练模型", log_file=config_log_file):
    print("训练中...")  # ✅ 也会被记录到同一个config_log_file
    train_model()

# 关闭日志管理器（关闭所有Tee对象）
step_logger.close()
```

### 普通模式（每个步骤一个文件）

```python
# 不指定log_file参数，每个步骤会创建独立的日志文件
with step_logger.step("步骤1: 训练模型"):
    print("训练中...")  # 记录到 trainlog/step_01_训练模型_20251210_120000.log

with step_logger.step("步骤2: 测试模型"):
    print("测试中...")  # 记录到 trainlog/step_02_测试模型_20251210_120000.log
```

## 日志记录保证

### ✅ 保证记录的内容

1. **所有print输出**：每次print都会立即写入文件
2. **所有logger输出**：`logger.info()`, `logger.error()`等
3. **所有stdout/stderr输出**：包括子进程的输出（如果正确配置）
4. **错误堆栈信息**：异常会自动记录完整堆栈

### ❌ 不记录的内容

1. **tqdm进度条**：自动过滤，保持日志简洁
2. **ES成功的HTTP请求**：只记录错误，不记录成功的请求（如`HEAD 200`）

## 技术细节

### 1. 为什么print会被记录？

```python
# 在step上下文管理器中
sys.stdout = Tee(log_file, original_stdout)  # 重定向stdout
sys.stderr = Tee(log_file, original_stderr)  # 重定向stderr

# 当执行print("hello")时
print("hello")  # 实际上调用 sys.stdout.write("hello\n")
                # 而sys.stdout是Tee对象，会同时写入文件和控制台
```

### 2. 为什么每次写入都刷新？

```python
def write(self, text):
    self.file.write(text)
    self.file.flush()  # ⚠️ 立即刷新，确保数据写入磁盘
```

**原因**：
- Python的文件写入默认有缓冲区
- 如果不刷新，数据可能还在内存中，程序崩溃时会丢失
- 立即刷新确保每次print都能被记录

### 3. 子进程输出如何捕获？

```python
# 在auto_pipeline.py中，使用subprocess.run时
# 不显式指定stdout/stderr，让子进程继承父进程的sys.stdout/sys.stderr
result = subprocess.run(
    command,
    shell=True,
    # 不指定stdout/stderr，子进程会使用父进程的sys.stdout/sys.stderr
    # 而父进程的sys.stdout/sys.stderr已经被重定向为Tee对象
)
```

### 4. Tee对象复用机制

```python
# 第一次使用
tee1 = _get_tee("config.log", 'stdout')  # 创建Tee，ref_count=1
sys.stdout = tee1

# 第二次使用同一个文件
tee2 = _get_tee("config.log", 'stdout')  # 复用Tee，ref_count=2
sys.stdout = tee2  # 同一个Tee对象

# 第一次结束
_release_tee("config.log")  # ref_count=1，不关闭

# 第二次结束
_release_tee("config.log")  # ref_count=0，关闭文件
```

## 常见问题

### Q1: 为什么我的print输出没有被记录？

**检查清单**：
1. ✅ 是否在`with step_logger.step()`上下文内？
2. ✅ 是否使用了`log_file`参数（数据集对比模式）？
3. ✅ 文件是否以追加模式打开（`'a'`模式）？
4. ✅ 是否调用了`file.flush()`？

### Q2: 为什么日志文件在子目录下？

**原因**：旧版本的`step_logger`会创建会话子目录。

**解决方案**：已更新为直接保存在`base_dir`下，不创建子目录。

### Q3: 多个步骤写入同一个文件时，为什么有些输出丢失？

**原因**：旧版本每个步骤结束时都会关闭文件，导致后续步骤无法写入。

**解决方案**：使用Tee对象复用机制，只有当所有步骤都结束时才关闭文件。

### Q4: 如何确保子进程的输出也被记录？

**方法**：
```python
# ✅ 正确：让子进程继承父进程的stdout/stderr
subprocess.run(command, shell=True)

# ❌ 错误：显式指定stdout/stderr会绕过Tee机制
subprocess.run(command, shell=True, stdout=sys.stdout, stderr=sys.stderr)
```

## 配置ES日志

系统已自动配置ES和urllib3的日志级别为ERROR：

```python
logging.getLogger('elasticsearch').setLevel(logging.ERROR)
logging.getLogger('urllib3').setLevel(logging.ERROR)
```

这意味着：
- ✅ **只记录错误**：只有ES请求失败时才会记录日志
- ❌ **不记录成功请求**：成功的HTTP请求（如`HEAD 200`）不会记录

## 进度条过滤

系统会自动过滤tqdm进度条输出：

```python
# 这个进度条不会记录到日志文件中
for i in tqdm(range(100)):
    pass

# 但其他print输出会记录
print("处理完成")  # ✅ 这个会记录
```

## 示例：完整的数据集对比模式

```python
from step_logger import StepLogger

step_logger = StepLogger(
    base_dir="trainlog",
    session_name="dataset_comparison",
    filter_tqdm=True
)

try:
    session_timestamp = step_logger.session_start_time.strftime('%Y%m%d_%H%M%S')
    
    for config_id, config_info in DATASET_CONFIGS.items():
        # 为每个配置创建一个统一的日志文件
        config_log_file = f"trainlog/{config_id}_{session_timestamp}.log"
        
        # 所有步骤的输出都写入这个文件
        with step_logger.step("步骤1: 更新配置", log_file=config_log_file):
            print("更新配置...")  # ✅ 记录到config_log_file
        
        with step_logger.step("步骤2: 训练模型", log_file=config_log_file):
            print("训练模型...")  # ✅ 追加到config_log_file
        
        with step_logger.step("步骤3: 测试模型", log_file=config_log_file):
            print("测试模型...")  # ✅ 追加到config_log_file
    
finally:
    step_logger.close()  # 关闭所有Tee对象
```

## 总结

**核心保证**：
1. ✅ **所有print输出都会被记录**：通过Tee机制重定向stdout/stderr
2. ✅ **每次写入都立即刷新**：确保数据不丢失
3. ✅ **文件以追加模式打开**：多个步骤可以写入同一个文件
4. ✅ **Tee对象复用**：避免重复创建和关闭文件
5. ✅ **所有日志文件直接保存在trainlog目录下**：不创建子目录

**这就是为什么你的print输出会被记录的原因！**
